; Ray tracer program

; LAYOUTS
; vec:
;     00..04 (f32) x
;     04..08 (f32) y
;     08..12 (f32) z
; camera:
;     00..12 (vec) location
;     12..24 (vec) direction
;     24..36 (vec) right
;     36..48 (vec) up
;     48..60 (vec) pixel_dir
; sphere:
;     00..12 (vec) center
;     12..16 (f32) radius

; GLOBAL VARIABLE SPANS
; camera   : (camera) 256000+00..60
; sphere 0 : (sphere) 256000+60..76
; sphere 1 : (sphere) 256000+76..92

call _start
halt

; args: y x color
; violates ax
_set_pixel:
    push 320
    mul
    add
    push 4
    mul
    pop ax
    pop [ax]
ret ; _set_pixel

; update camera with time
; ax - *vec3
; result on stack
_vec_to_color:
    push [ax+0]
    push 1.0
    fadd
    push 0.5
    fmul
    push 255.0
    fmul
    ftoi

    push [ax+4]
    push 1.0
    fadd
    push 0.5
    fmul
    push 255.0
    fmul
    ftoi

    push 8
    shl

    push [ax+8]
    push 1.0
    fadd
    push 0.5
    fmul
    push 255.0
    fmul
    ftoi

    push 16
    shl

    or
    or
ret ; _vec_to_color

_start:
    ; set video mode
    ; 1011 - manual update, true color
    push 0xB
    vsm

    ; setup sphere 0
    push 2.0
    pop [256060]
    push 0.0
    pop [256064]
    push 0.0
    pop [256068]
    push 2.0
    pop [256072]

    ; setup sphere 1
    push 2.0
    fneg
    pop  [256076]
    push 0.0
    pop  [256080]
    push 0.0
    pop  [256084]
    push 1.0
    pop  [256088]

    _start__main_loop:
        ; new frame loop

        ; update camera
        call _camera_update

        ; initialize Y counter
        push 0
        pop cx

        _start__yloop:

            ; initialize X counter
            push 0
            pop bx

            _start__xloop:
                 ; calculate vector pointing to (bx, cx) pixel
                 call _camera_calculate_pixel_vector

                 ; calculate environment color
                 push 256048
                 pop ax
                 call _vec_to_color

                 ; calculate first sphere intersection
                 push 256060
                 pop ax
                 call _camera_check_sphere_intersection
                 push ax

                 ; calculate second sphere intersection
                 push 256076
                 pop ax
                 call _camera_check_sphere_intersection
                 push ax

                 ; just...or the colors (that's MUCH MORE SIMPLER, than sorting 'em by distance etc.)
                 or
                 or

                 ; set pixel on X, Y
                 push bx
                 push cx
                 call _set_pixel

                 ; increment and check
                 push bx
                 push 1
                 add
                 pop bx

                 push bx
                 push 320
                 cmp
                 jne _start__xloop
            ; increment and check
            push cx
            push 1
            add
            pop cx

            push cx
            push 200
            cmp
            jne _start__yloop

        vrs
        jmp _start__main_loop
ret ; _start

; main.cfasm
