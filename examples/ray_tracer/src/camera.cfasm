; Camera module (uses global variables declared in main.cfasm)

_camera_update:
    push ax
    push bx
    push cx

    time
    push 1.0
    fdiv
    pop ax

    ; x = cos(time) * 10.0
    push ax
    fcos
    push 10.0
    fmul
    pop [256000]

    ; y = 8.0
    push 8.0
    pop [256004]

    ; z = sin(time) * 10.0
    push ax
    fsin
    push 10.0
    fmul
    pop [256008]

    ; ax = &direction
    ; bx = &location
    ; direction = -normalize(location)
    push 256012
    pop ax
    push 256000
    pop bx
    call _vec_copy
    call _vec_normalize
    call _vec_negate

    ; ax = &right
    ; bx = &direction
    ; cx = &up
    push 256024
    pop ax
    push 256012
    pop bx
    push 256036
    pop cx

    ; up = (0, 1, 0)
    push 0.0
    push 1.0
    push 0.0
    pop [cx+0]
    pop [cx+4]
    pop [cx+8]

    ; right = normalize(direction % up)
    call _vec_cross
    call _vec_normalize

    ; up = normalize(right % direction)
    push 256036 ; up
    pop ax
    push 256024 ; right
    pop bx
    push 256012 ; direction
    pop cx
    call _vec_cross
    call _vec_normalize

    pop cx
    pop bx
    pop ax
ret ; _camera_update

; bx, cx = x, y
_camera_calculate_pixel_vector:
    push ax
    push bx
    push cx

    push 256048
    pop  ax

    ; nx = x * (320 / 2) - 1
    push bx
    itof
    push 160.0
    fdiv
    push 1.0
    fsub
    pop bx

    ; ny = y * (200 / 2) - 1
    push cx
    itof
    push 100.0
    fdiv
    push 1.0
    fsub
    pop cx

    ; ax = right * bx + up * cx + direction

    push [256024]
    push bx
    fmul
    push [256036]
    push cx
    fmul
    push [256012]
    fadd
    fadd
    pop [ax+0]

    push [256028]
    push bx
    fmul
    push [256040]
    push cx
    fmul
    push [256016]
    fadd
    fadd
    pop [ax+4]

    push [256032]
    push bx
    fmul
    push [256044]
    push cx
    fmul
    push [256020]
    fadd
    fadd
    pop [ax+8]

    ; normalize vec3
    call _vec_normalize

    pop cx
    pop bx
    pop ax
ret ; _camera_calculate_pixel_vector

; sphere: ax
; result: ax
; checks intersection with current pixel_dir (256048)
_camera_check_sphere_intersection:
    push bx
    push cx

    ; bx = dot(sphere.position - location, pixel_dir)
    push [ax+0]
    push [256000]
    fsub
    push [256048]
    fmul

    push [ax+4]
    push [256004]
    fsub
    push [256052]
    fmul

    push [ax+8]
    push [256008]
    fsub
    push [256056]
    fmul

    fadd
    fadd
    pop bx

    push [256048]
    push bx
    fmul
    push [256000]
    fadd
    push [ax+0]
    fsub
    pop cx
    push cx
    push cx
    fmul

    push [256052]
    push bx
    fmul
    push [256004]
    fadd
    push [ax+4]
    fsub
    pop cx
    push cx
    push cx
    fmul

    push [256056]
    push bx
    fmul
    push [256008]
    fadd
    push [ax+8]
    fsub
    pop cx
    push cx
    push cx
    fmul

    fadd
    fadd
    fsqrt
    push [ax+12]
    fsub
    push 31
    sar
    pop ax

    pop cx
    pop bx
ret ; _camera_check_sphere_intersection

; camera.cfasm
